# 9-区域操作

> 绘制ROI区域，是在窗口上进行绘制，需要获取绘制窗口

# 获取窗口

```python
dev_get_window (WindowHandle)
```

# 绘制矩形1

```python
draw_rectangle1 (WindowHandle, Row1, Column1, Row2, Column2)
```

- `( Row1, Column1)`:矩形左上点坐标
- `（Row2, Column2)）`：矩形右下点坐标

运行完改行代码后，可以按住鼠标左键在图形窗口拉出一个矩阵，拉完后可以 对四条边框进行修改（上下和左右移动）,确定后点击鼠标右键，完成矩形拉框

```python
gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2)
```

在图像窗口显示刚刚绘制的矩阵

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202508242153398.png" alt="image-20250824215344325" style="zoom:33%;" />

# 绘制矩形2

```python
draw_rectangle2 (WindowHandle, Row, Column, Phi, Length1, Length2)
```

> 可以看到矩形2 是带有旋转角度的，画完后仍然点击鼠标右键结束拉框绘制
>
> <img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202508242156643.png" alt="image-20250824215617596" style="zoom:33%;" />

```python
gen_rectangle2 (Rectangle1, Row, Column, Phi, Length1, Length2)
```

# 绘制圆

> 具体操作跟矩阵一样（先运行，再按住左键拉框，右击确认）

```python
draw_circle (WindowHandle, Row3, Column3, Radius)
gen_circle (Circle, Row3, Column3, Radius)
```

# 绘制椭圆

```python
draw_ellipse (WindowHandle, Row4, Column4, Phi1, Radius1, Radius2)
gen_ellipse (Ellipse, Row4, Column4, Phi1, Radius1, Radius2)
```

> 若图像变量区域没有出现图像，可以清除变量后多试几次

# 画直线

```python
draw_line (WindowHandle, Row11, Column11, Row21, Column21)
gen_region_line (RegionLines, Row11, Column11, Row21, Column21)
```

- `( Row11, Column11)`:绘制线时的起点坐标
- `(Row21, Column21)`：绘制线时的终起点坐标

# 绘制任意区域

> 具体操作跟矩阵一样（先运行，再按住左键拉框，右击确认）

```python
draw_region (Region, WindowHandle)
```

# 区域的形态学操作

## 腐蚀

### 圆形腐蚀

```python
erosion_circle (Region, RegionErosion, 3.5)
```

### 矩形腐蚀

```python
erosion_rectangle1 (RegionErosion, RegionErosion1, 3, 3)
```

> - 以像素点为中心， 3X3 的方形区域内都有像素值，则该像素点不会被腐蚀。
>
> - 如果输入区域是一个 10×10 的方块，经过 `erosion_rectangle1(..., 3, 3)` 处理后，输出会变成一个 8×8 的方块（四周各收缩一圈）

## 膨胀

### 圆形膨胀

```python
dilation_circle (RegionErosion1, RegionDilation, 3.5)
```

## 矩形膨胀

```python
dilation_rectangle1 (RegionDilation, RegionDilation1, 11, 11)
```

# 区域之间的计算

## 交集

```python
* 清除句柄窗口的图像
dev_clear_window ()

* 绘制任意区域1
draw_region (Region1, WindowHandle)

* 绘制任意区域2
draw_region (Region2, WindowHandle)

* 区域之间的交集
intersection (Region1, Region2, RegionIntersection)
```

# 差集

```python
* 区域之间的差集
difference (Region1, Region2, RegionDifference)
```

`RegionDifference` 显示的区域为$Region1 - Region1 \cap Region2$

## 并集

```python
union2 (Region1, Region2, RegionUnion)
```

## 补集（用的较少）

```python
complement (Region1, RegionComplement)
```

`RegionComplement` 显示的区域为整个`WindowHandle`（511* 511）中去除`Region1` 的其他区域

# 区域形状的变化

```python
* Region1 的最小外接凸多边形（没有任何凹陷位的多边形）
shape_trans (Region1, RegionTrans, 'convex')

* Region1 的最小外接矩形（与窗口方向一致）
shape_trans (Region1, RegionTrans, 'rectangle1')

* Region1 的最小外接带角度矩形
shape_trans (Region1, RegionTrans0, 'rectangle2')

* Region1 的最小内圆
shape_trans (Region1, RegionTrans1, 'inner_circle')

* Region1 的最小外圆
shape_trans (Region1, RegionTrans2, 'outer_circle')
```

# 移动区域

```python
move_region (Region1, RegionMoved, 100, 100)
```

Region1 的中心依次向右后向下移动100个像素（右移和下移为正，跟x轴和y轴方向一致）

# 仿射变换

## 移动变换矩阵

```python
* 生成变换矩阵
vector_angle_to_rigid(0, 0, 0, 0, -100, 0, HomMat2D)

* 对区域进行移动
affine_trans_region(Region1, RegionAffineTrans, HomMat2D, 'false')
```

`affine_trans_region(Region : RegionAffineTrans : HomMat2D, Interpolate : )`

- 对区域进行 HomMat2D 矩阵变换
- `Interpolat`:否在内部使用插值来完成.插值可以使区域边界更平滑，特别是当区域被放大时，会导致运行时间显著增加

`ector_angle_to_rigid( : : Row1, Column1, Angle1, Row2, Column2, Angle2 : HomMat2D)`

- 平移矩阵由于没有获取旋转中心坐标和area，只能进行平移
- （Row1, Column1）：变换前的坐标
- （Row2, Column2）：变换后的坐标
- `Angle1`:变换前的角度
- `Angle2`:变换后的角度

## 角度变换矩阵

```python
* 获取旋转中心
area_center (RegionMoved, Area, Row5, Column5)

* 生成对应旋转变换矩阵
vector_angle_to_rigid (Row5, Column5, 0, Row5, Column5, rad(90), HomMat2D1)
* rad(90) 也可以用3.1415 来代替
* 若 angle1 = rad(90), angle2=0,则相当于是angle1=0， angle2=rad(-90)[相对变换]

* 使用变换矩阵进行旋转
affine_trans_region (RegionMoved, RegionAffineTrans1, HomMat2D1, 'nearest_neighbor')
* 采用最近邻进行插值

```

