<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.0.1">
<procedure name="main">
<interface/>
<body>
<c>* 平滑卷积X长度</c>
<l>SmoothX := 501</l>
<c>* 阈值偏置</c>
<l>ThresholdOffset := 25</l>
<c>* 最小缺陷大小</c>
<l>MinDefectSize := 50</l>
<c>* 极坐标分辨率</c>
<l>PolarResolution := 640</l>
<c>* 环大小</c>
<l>RingSize := 70</l>
<c>* 获取空区域对象</c>
<l>get_system ('store_empty_region', StoreEmptyRegion)</l>
<l>set_system ('store_empty_region', 'false')</l>
<c>* 读取图像</c>
<l>read_image (Image, 'bottles/bottle_mouth_01')</l>
<c>* 更新设备</c>
<l>dev_update_off ()</l>
<c>* 关闭窗口</c>
<l>dev_close_window ()</l>
<l>dev_close_window ()</l>
<c>* 打开固定大小窗口</c>
<l>dev_open_window_fit_image (Image, 0, 0, 640, 512, WindowHandle1)</l>
<c>* 设置显示字体的大小</c>
<l>set_display_font (WindowHandle1, 16, 'mono', 'true', 'false')</l>
<c>* 显示图像</c>
<l>dev_display (Image)</l>
<c>* 设置显示模式</c>
<l>dev_set_draw ('margin')</l>
<c>* 设置显示线宽</c>
<l>dev_set_line_width (3)</l>
<c>* 打开固定大小窗口</c>
<l>dev_open_window_fit_size (0, 648, RingSize, PolarResolution, 150, 512, WindowHandle)</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (3)</l>
<l>dev_set_color ('red')</l>
<c>* 遍历</c>
<l>for Index := 1 to 16 by 1</l>
<c>    * 读取图像</c>
<l>    read_image (Image, 'bottles/bottle_mouth_' + Index$'.02')</l>
<c>    * 阈值分割</c>
<c>    * 1.获取输入图像的灰度直方图</c>
<c>    * 2.使用标准差为Sigma的一维高斯滤波器对直方图进行滤波</c>
<c>    * 3.计算滤波后的直方图的极小值</c>
<c>    * 4.以计算得到的极小值所对应的灰度值为分割阈值对图像进行分割</c>
<c>    * 直方图阈值分割</c>
<l>    auto_threshold (Image, Regions, 2)</l>
<c>    * 选择分割区域</c>
<l>    select_obj (Regions, DarkRegion, 1)</l>
<c>    * 开运算</c>
<l>    opening_circle (DarkRegion, RegionOpening, 3.5)</l>
<c>    * 闭运算</c>
<l>    closing_circle (RegionOpening, RegionClosing, 25.5)</l>
<c>    * 填充</c>
<l>    fill_up (RegionClosing, RegionFillUp)</l>
<c>    * 获取边界</c>
<l>    boundary (RegionFillUp, RegionBorder, 'outer')</l>
<c>    * 膨胀</c>
<l>    dilation_circle (RegionBorder, RegionDilation, 3.5)</l>
<c>    * 获取区域图像</c>
<l>    reduce_domain (Image, RegionDilation, ImageReduced)</l>
<c>    * 获取边缘</c>
<l>    edges_sub_pix (ImageReduced, Edges, 'canny', 0.5, 20, 40)</l>
<c>    * 分割轮廓</c>
<l>    segment_contours_xld (Edges, ContoursSplit, 'lines_circles', 5, 4, 2)</l>
<c>    * 合并轮廓</c>
<l>    union_cocircular_contours_xld (ContoursSplit, UnionContours, 0.9, 0.5, 0.5, 200, 50, 50, 'true', 1)</l>
<c>    * 轮廓个数</c>
<l>    length_xld (UnionContours, Length)</l>
<c>    * 选择对象</c>
<l>    select_obj (UnionContours, LongestContour, sort_index(Length)[|Length| - 1] + 1)</l>
<c>    * 拟合圆轮廓</c>
<l>    fit_circle_contour_xld (LongestContour, 'ahuber', -1, 0, 0, 3, 2, Row, Column, Radius, StartPhi, EndPhi, PointOrder)</l>
<c>    * </c>
<c>    * Part 2: Transform the ring-shaped bottle neck region to a rectangle</c>
<c>    * 生成圆</c>
<l>    gen_circle (Circle, Row, Column, Radius)</l>
<c>    * 膨胀</c>
<l>    dilation_circle (Circle, RegionDilation, 5)</l>
<c>    * 腐蚀</c>
<l>    erosion_circle (Circle, RegionErosion, RingSize - 5)</l>
<c>    *区域相减</c>
<l>    difference (RegionDilation, RegionErosion, RegionDifference)</l>
<c>    * 获取区域图像</c>
<l>    reduce_domain (Image, RegionDifference, ImageReduced)</l>
<c>    * 极坐标转换</c>
<l>    polar_trans_image_ext (ImageReduced, ImagePolar, Row, Column, 0, rad(360), Radius - RingSize, Radius, PolarResolution, RingSize, 'nearest_neighbor')</l>
<c>    * </c>
<c>    * Part 3: Find defects with a dynamic threshold</c>
<c>    * 灰度值拉伸到0-255</c>
<l>    scale_image_max (ImagePolar, ImageScaleMax)</l>
<c>    * 均值滤波</c>
<l>    mean_image (ImageScaleMax, ImageMean, SmoothX, 3)</l>
<c>    * 动态阈值分割</c>
<l>    dyn_threshold (ImageScaleMax, ImageMean, Regions1, 55, 'not_equal')</l>
<c>    * 连通</c>
<l>    connection (Regions1, Connection)</l>
<c>    * 根据特征选取区域</c>
<l>    select_shape (Connection, SelectedRegions, 'height', 'and', 9, 99999)</l>
<c>    * 闭运算</c>
<l>    closing_rectangle1 (SelectedRegions, RegionClosing1, 10, 20)</l>
<c>    * 区域合并</c>
<l>    union1 (RegionClosing1, RegionUnion)</l>
<c>    * re-transform defect regions for visualization</c>
<l>    polar_trans_region_inv (RegionUnion, XYTransRegion, Row, Column, 0, rad(360), Radius - RingSize, Radius, PolarResolution, RingSize, 1280, 1024, 'nearest_neighbor')</l>
<c>    * </c>
<c>    * Part 4: Display results</c>
<c>    * 显示结果</c>
<l>    dev_set_window (WindowHandle1)</l>
<l>    dev_display (Image)</l>
<l>    dev_set_color ('blue')</l>
<l>    dev_display (RegionDifference)</l>
<l>    dev_set_color ('red')</l>
<l>    dev_display (XYTransRegion)</l>
<c>    * display polar transformed inspected region with results</c>
<c>    * The image and resulting region are rotated by 90 degrees</c>
<c>    * only for visualization purposes! (I.e. to fit better on the screen)</c>
<c>    * The rotation is NOT necessary for the detection algorithm.</c>
<l>    dev_set_window (WindowHandle)</l>
<c>    * 旋转图像（重要）</c>
<l>    rotate_image (ImagePolar, ImageRotate, 90, 'constant')</l>
<l>    dev_display (ImageRotate)</l>
<c>    * 区域计数</c>
<l>    count_obj (RegionUnion, Number)</l>
<l>    if (Number &gt; 0)</l>
<l>        mirror_region (RegionUnion, RegionMirror, 'diagonal', PolarResolution)</l>
<l>        mirror_region (RegionMirror, RegionMirror, 'row', PolarResolution)</l>
<l>        dev_display (RegionMirror)</l>
<l>        disp_message (WindowHandle1, 'Not OK', 'window', 12, 12, 'red', 'false')</l>
<l>    else</l>
<l>        disp_message (WindowHandle1, 'OK', 'window', 12, 12, 'forest green', 'false')</l>
<l>    endif</l>
<l>    if (Index &lt; 16)</l>
<l>        disp_continue_message (WindowHandle1, 'black', 'true')</l>
<l>        stop ()</l>
<l>    endif</l>
<l>endfor</l>
<c>* Reset system parameters</c>
<l>set_system ('store_empty_region', StoreEmptyRegion)</l>
<c></c>
<c></c>
<c></c>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
